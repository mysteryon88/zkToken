// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.17;

import "./Pairing.sol";

contract TransferVerifier {
    using Pairing for *;
    struct VerifyingKey {
        Pairing.G1Point alfa1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;
        Pairing.G1Point[] IC;
    }
    struct Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;
    }

    function verifyingKey() internal pure returns (VerifyingKey memory vk) {
        vk.alfa1 = Pairing.G1Point(
            881611117736465254789829608766632480590457768303498178602820786428451805489,
            2307069010697406853254075879547810742427851003580885580339621187462444382685
        );

        vk.beta2 = Pairing.G2Point(
            [
                20384691298706876075002979950908578638601338202848416053019772945445941819203,
                6420877688986346447291383378819242934176726911275118801504248419871108093280
            ],
            [
                14848369707109194530976688325017076720773371158186757357933216223669775637633,
                15452135041904015003850431891738190338003701901251357396364635535813851414573
            ]
        );
        vk.gamma2 = Pairing.G2Point(
            [
                11559732032986387107991004021392285783925812861821192530917403151452391805634,
                10857046999023057135944570762232829481370756359578518086990519993285655852781
            ],
            [
                4082367875863433681332203403145435568316851327593401208105741076214120093531,
                8495653923123431417604973247489272438418190587263600148770280649306958101930
            ]
        );
        vk.delta2 = Pairing.G2Point(
            [
                12822234086557546782330252208506308811964466265876322030986687700407939388320,
                2507027247456796263008716531832864946143938898221195653751776374970937098713
            ],
            [
                3132000826106007729712875206850486090455516556747994343725354508630567638797,
                7757013765625134708341986575074290238579288115290533893539767638663157032996
            ]
        );
        vk.IC = new Pairing.G1Point[](12);

        vk.IC[0] = Pairing.G1Point(
            19169981791181061841070582845927514389567170132059621461535423359145945401342,
            18315940568386031644987726648844548268909854584878306532211549885246079321147
        );

        vk.IC[1] = Pairing.G1Point(
            5501993479251931293473131746929233405907728834131371823222054063772059107216,
            16774618400013092026045459588683441909373681026765899247726590157647631141621
        );

        vk.IC[2] = Pairing.G1Point(
            14208360977841027830997568749515165181211897769848476805646324292200878522297,
            2049218369245394898371945785377247833141033530533528041204115878046444115435
        );

        vk.IC[3] = Pairing.G1Point(
            12125937157910429075923528471254995928145179502214850016052546609310068080396,
            3671603334338689274156499979267003153527716760325814356965909161742440636859
        );

        vk.IC[4] = Pairing.G1Point(
            10887804941817406668470825702144915109174359480516601148976727055226759508566,
            4090394086713459576923947301611643501297864359996839055412490254844498725550
        );

        vk.IC[5] = Pairing.G1Point(
            18550640952648104315538207148264861059399223515106652518926500352022987164022,
            7486789824040520788521870832864863756334811540924618232694213942893107520827
        );

        vk.IC[6] = Pairing.G1Point(
            7672763630848979691846413611192608849013624189743309799750427473682870070567,
            19048753781181639521972464051150020822499329184861317301100261451624389427510
        );

        vk.IC[7] = Pairing.G1Point(
            7307585956664646760639336302736485027963002840536915096460517966961401506573,
            15454844226058367145256807022993503649401332541485454604654484256531132161371
        );

        vk.IC[8] = Pairing.G1Point(
            11068922664552430585942026789350773824284263160563435261827330904730806477387,
            7182744390814362884961117574079438809905326646490954812598856843018103657789
        );

        vk.IC[9] = Pairing.G1Point(
            17640360338230945589019877202364798307601408461289039827128280645095089264257,
            6951349576871692662136584453188507148939805874635550629208042541830832008957
        );

        vk.IC[10] = Pairing.G1Point(
            21371744386609055527036301280602897254883407028878234918838887224770615828497,
            20489419108808306245863654417194275363863194904596709077492079139800456612053
        );

        vk.IC[11] = Pairing.G1Point(
            12200377723665483672632155778033467930794987816544085099778713665088503606619,
            2975770684310723290710715123408354078872691853092019921670699216642239546965
        );
    }

    function verify(
        uint[] memory input,
        Proof memory proof
    ) internal view returns (uint) {
        uint256 snark_scalar_field = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
        VerifyingKey memory vk = verifyingKey();
        require(input.length + 1 == vk.IC.length, "verifier-bad-input");
        // Compute the linear combination vk_x
        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);
        for (uint i = 0; i < input.length; i++) {
            require(
                input[i] < snark_scalar_field,
                "verifier-gte-snark-scalar-field"
            );
            vk_x = Pairing.addition(
                vk_x,
                Pairing.scalar_mul(vk.IC[i + 1], input[i])
            );
        }
        vk_x = Pairing.addition(vk_x, vk.IC[0]);
        if (
            !Pairing.pairingProd4(
                Pairing.negate(proof.A),
                proof.B,
                vk.alfa1,
                vk.beta2,
                vk_x,
                vk.gamma2,
                proof.C,
                vk.delta2
            )
        ) return 1;
        return 0;
    }

    /// @return r  bool true if proof is valid
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint /*11*/[] memory input
    ) public view returns (bool r) {
        Proof memory proof;
        proof.A = Pairing.G1Point(a[0], a[1]);
        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
        proof.C = Pairing.G1Point(c[0], c[1]);
        uint[] memory inputValues = new uint[](input.length);
        for (uint i = 0; i < input.length; i++) {
            inputValues[i] = input[i];
        }
        if (verify(inputValues, proof) == 0) {
            return true;
        } else {
            return false;
        }
    }
}
